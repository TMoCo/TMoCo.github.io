---
layout: post
title:  "Vulkan Terrain Rendering"
titlePicture:  "/assets/TerrainRendering.png"
category: portfolio
permalink: "/Vulkan_Terrain_Rendering/"
repo: "HPG2ATerrainRendering"
---

<!--end-excerpt-->

![TerrainRendering]({{ site.url }}/assets/TerrainRendering.png)

The goal of this coursework was to explore terrain rendering though the Vulkan API. The terrain is generated by reading values from a grayscale height map and using them as the Y value of vertices in an XZ plane.\
Interestingly, __gl_VertexIndex__ can be used to bypass the need to send vertex data to the GPU by invoking VkCmdDraw or VkCmdDrawIndexed without binding a vertex buffer.
{% highlight glsl %}
int id = gl_VertexIndex;
int row = id / mapSize;
int col = id / mapSize;
vec2 uv = vec2(row / (float)mapSize, col / (float)mapSize);
vec3 position = vec3(
     row - mapSize / 2.0f,
     texture(heightSampler, uv),
     col - mapSize / 2.0f);
{% endhighlight %}
A typical optimisation of terrain rendering is to apply binning to the terrain, separating sections of it into bins, and only rendering those visible. I opted to divide the terrain into even sections and use the dot product of the bin's midpoint with the camera's view direction.\
\
![BinnedTerrain]({{ site.url }}/assets/BinnedTerrain.gif)\
This was sufficient for the coursework but is not ideal (enter kd-trees, LOD tesselation on the GPU...). I hope to revisit this project and explore more terrain rendering techniques with my improved C++ and Vulkan knowledge.
